#Top-level tests

##Importing what is needed

    >>> from the_eye import string_or_stdin
    >>> import pandas as pd
    >>> import facebook_comments as fc

##Testing string_or_stdin

Words should be left untouched

    >>> all(string_or_stdin(s) == s
    ...     for s in "a b c foo bar complex-word something".split())
    True

'-' should read from stdin (mocking this one)

    >>> string_or_stdin('-', raw_input=lambda:'Reading from stdin')
    'Reading from stdin'
    >>> string_or_stdin('-', raw_input=lambda:"foobar")
    'foobar'
    >>> string_or_stdin('-', raw_input=lambda:"""-""")
    '-'

#Facebook_comments tests

##Module tests

    >>> def mock_fetch(self, path):
    ...     for i in range(10):
    ...         yield ['2015-06-{:02}T{:02}:00:00+0000'.format(j+1, i) for j in range(20)]
    >>> fc.utils.FacebookComments._fetch = mock_fetch
    >>> serie = fc.read_from_facebook(None, None)
    >>> len(serie.histogram)
    200
    >>> def will_fail_generator():
    ...     for i in xrange(10):
    ...         yield i
    ...     raise Exception()
    ...     for i in xrange(10, 20):
    ...         yield i
    >>> generated = list(fc.failsafe_generator(will_fail_generator()))
    >>> generated == range(10)
    True
    >>> list(fc.failsafe_generator('abracadabra'))
    ['a', 'b', 'r', 'a', 'c', 'a', 'd', 'a', 'b', 'r', 'a']
    

##Utils tests

###Creating some objects

    >>> def mock_fetch(self, path):
    ...     yield ['03 08 2015 145623']
    ...     yield ['03 08 2015 145624']
    ...     yield ['03 08 2015 145625']
    ...     yield ['12 06 2015 213452']
    ...     yield ['23 12 2015 145632']
    ...     yield ['17 09 2015 030000']
    ...     yield ['01 03 2016 124300']
    ...     yield ['07 02 2015 231443']
    ...     yield ['07 02 2016 123227']
    >>> fc.utils.FacebookComments._fetch = mock_fetch
    >>> parser = fc.utils.FacebookComments(None)
    >>> list(parser.analyze(None))
    ['03 08 2015 145623', '03 08 2015 145624', '03 08 2015 145625', '12 06 2015 213452', '23 12 2015 145632', '17 09 2015 030000', '01 03 2016 124300', '07 02 2015 231443', '07 02 2016 123227']
    >>> fc.utils.TimeSeries().histogram
    Series([], dtype: int64)
    >>> storage = fc.utils.TimeSeries(parser.analyze(None), '%d %m %Y %H%M%S')
    >>> storage.histogram
    2015-02-07 23:14:00    1
    2015-06-12 21:34:00    1
    2015-08-03 14:56:00    3
    2015-09-17 03:00:00    1
    2015-12-23 14:56:00    1
    2016-02-07 12:32:00    1
    2016-03-01 12:43:00    1
    dtype: int64

###Testing frequency truncating

    >>> fc.utils.TimeSeries.truncate_to_frequency('12 June 2042, 21H43')
    Traceback (most recent call last):
    ...
    AttributeError: 'str' object has no attribute 'value'
    >>> ref = pd.Timestamp('12 June 2042, 21H43')
    >>> fc.utils.TimeSeries.truncate_to_frequency(ref, '15min')
    Timestamp('2042-06-12 21:30:00')
    >>> fc.utils.TimeSeries.truncate_to_frequency(ref, '20min')
    Timestamp('2042-06-12 21:40:00')
    >>> fc.utils.TimeSeries.truncate_to_frequency(ref, '1H')
    Timestamp('2042-06-12 21:00:00')
    >>> fc.utils.TimeSeries.truncate_to_frequency(ref, '2H')
    Timestamp('2042-06-12 20:00:00')
    >>> fc.utils.TimeSeries.truncate_to_frequency(ref, '1D')
    Timestamp('2042-06-12 00:00:00')
    >>> fc.utils.TimeSeries.truncate_to_frequency(ref, '1M')
    Traceback (most recent call last):
    ...
    AttributeError: 'MonthEnd' object has no attribute 'delta'
    >>> fc.utils.TimeSeries.truncate_to_frequency(ref, '1MS')
    Traceback (most recent call last):
    ...
    AttributeError: 'MonthBegin' object has no attribute 'delta'


###Testing multi-scale analysis

    >>> no_data = fc.utils.TimeSeries().statistics('26 jan 2014')
    >>> hours, days, months, years = no_data
    >>> months == years
    True
    >>> months
    OrderedDict()
    >>> sum(hours.values()) == sum(days.values()) == 0
    True
    >>> min(hours)
    Timestamp('2014-01-26 00:00:00', offset='20T')
    >>> max(hours)
    Timestamp('2014-01-27 00:00:00', offset='20T')
    >>> len(hours)
    73
    >>> min(days)
    Timestamp('2014-01-11 00:00:00', offset='D')
    >>> max(days)
    Timestamp('2014-02-10 00:00:00', offset='D')
    >>> len(days)
    31
    >>> hours, days, months, years = storage.statistics(
    ...     '20 February 2016, 1H30',
    ...     days_focussed=20,
    ...     minutes_interval=15)
    >>> years
    OrderedDict([(Timestamp('2015-01-01 00:00:00', offset='AS-JAN'), 7), (Timestamp('2016-01-01 00:00:00', offset='AS-JAN'), 2)])
    >>> for date, amount in months.iteritems():
    ...   print date.strftime('%m %Y'), int(amount)
    02 2015 1
    03 2015 0
    04 2015 0
    05 2015 0
    06 2015 1
    07 2015 0
    08 2015 3
    09 2015 1
    10 2015 0
    11 2015 0
    12 2015 1
    01 2016 0
    02 2016 1
    03 2016 1
    >>> [(d, int(a)) for d, a in days.iteritems() if a]
    [(Timestamp('2016-02-07 00:00:00', offset='D'), 1), (Timestamp('2016-03-01 00:00:00', offset='D'), 1)]
    >>> min(days)
    Timestamp('2016-01-31 00:00:00', offset='D')
    >>> max(days)
    Timestamp('2016-03-11 00:00:00', offset='D')
    >>> len(days)
    41
    >>> min(hours)
    Timestamp('2016-02-20 00:00:00', offset='15T')
    >>> max(hours)
    Timestamp('2016-02-21 00:00:00', offset='15T')
    >>> len(hours)
    97
    >>> sum(hours.values())
    0.0

##Prettyfier tests

    >>> import sys
    >>> pretty = fc.prettyfiers.Prettyfier(sys.stdout)
    >>> pretty.new_document(storage.statistics('2016-12-31', days_focussed=3, minutes_interval=720))
    Today:
        2016-12-31 00:00:00:    0
        2016-12-31 12:00:00:    0
        2017-01-01 00:00:00:    0
    Past and coming days:
        2016-12-28 00:00:00:    0
        2016-12-29 00:00:00:    0
        2016-12-30 00:00:00:    0
        2016-12-31 00:00:00:    0
        2017-01-01 00:00:00:    0
        2017-01-02 00:00:00:    0
        2017-01-03 00:00:00:    0
    By month:
        2015-02-01 00:00:00:    1
        2015-03-01 00:00:00:    0
        2015-04-01 00:00:00:    0
        2015-05-01 00:00:00:    0
        2015-06-01 00:00:00:    1
        2015-07-01 00:00:00:    0
        2015-08-01 00:00:00:    3
        2015-09-01 00:00:00:    1
        2015-10-01 00:00:00:    0
        2015-11-01 00:00:00:    0
        2015-12-01 00:00:00:    1
        2016-01-01 00:00:00:    0
        2016-02-01 00:00:00:    1
        2016-03-01 00:00:00:    1
    By year:
        2015-01-01 00:00:00:    7
        2016-01-01 00:00:00:    2

